<!DOCTYPE html>
<html>
	<head>
		<style>
			html,body{margin:0px; padding:0px; width:100%; height:100%;}
			body{background-color:#404040;}

			canvas{border:1px solid black;}
			div{display:flex; width:100%; height:100%; align-items:center; justify-content:center;}
		</style>

		<script src="gl.js"></script>
		<script src="Math.js"></script>
		<script src="shaders.js"></script>
		<script src="RenderLoop.js"></script>
		<script src="Modal.js"></script>
		<script src="Transform.js"></script>
		<script src="Primatives.js"></script>
		<script src="maze.js"></script>
		<script src="Camera.js"></script>
		<script src="Shaders_Extra.js"></script>

		<script>
			var gl, gRLoop,	gShader, gModal, gCamera, gCameraCtrl, gQuadModalShader;
			var gGridShader, gGridModal, gQuadModal;

			window.addEventListener("load",function(){
				//Main Setup
				gl = GLInstance("glcanvas").fFitScreen(0.95,0.7).fClear(); //.fSetSize(500,500)

				gCamera = new Camera(gl);
				gCamera.transform.position.set(0,1,3);
				gCameraCtrl = new CameraController(gl,gCamera);
				
				//....................................
				//Load up resources
				gl.fLoadTexture("tex001",document.getElementById("imgTex"));

				//Setup shaders
				gGridShader = new GridAxisShader(gl,gCamera.projectionMatrix);
				gQuadModalShader = new TestShader(gl,gCamera.projectionMatrix);
				// gShader = new TestShader(gl,[ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0]); //Gray,Red,Green,Blue
				gShader = new TestShader(gl,gCamera.projectionMatrix).setTexture(gl.mTextureCache["tex001"]);

				var laberintoHardCodeado = mazePrim(20,20);
				Primatives.GridAxis.createModal(gl,laberintoHardCodeado);
				updateCanvas(laberintoHardCodeado);
				
				// creo un quad para mostrarlo y testing
				// gQuadModal = Primatives.Quad.createModal(gl, laberintoHardCodeado);
				
				//Start Rendering
				RLoop = new RenderLoop(onRender).start();
				
			});

			function onRender(){
				gCamera.updateViewMatrix();
				gl.fClear();
				
				gGridShader.activate()
					.setCameraMatrix(gCamera.viewMatrix)
					.renderModal( gGridModal.preRender() );

				gShader.activate().preRender()
				.setCameraMatrix(gCamera.viewMatrix)
				.renderModal( gQuadModal.preRender() );
			}

			function updateCanvas(laberintoCreado){
				Primatives.GridAxis.createModal(gl,laberintoCreado);
				gQuadModal = new Modal(gl.mMeshCache["paredes"]);
				// gGridModal = Primatives.GridAxis.createModal(gl,laberintoCreado);

				// aca se muestra
				gGridModal = new Modal(gl.mMeshCache["grid"]);

				onRender();
			}

			class TestShader extends Shader{
				constructor(gl,pMatrix){
					var vertSrc = ShaderUtil.domShaderSrc("vertex_shader"),
						fragSrc = ShaderUtil.domShaderSrc("fragment_shader");
					super(gl,vertSrc,fragSrc);

					// //Our shader uses custom uniforms 
					// var uColor	= gl.getUniformLocation(this.program,"uColor");
					// gl.uniform3fv(uColor, aryColor);

					// gl.useProgram(null); //Done setting up shader

					//Standrd Uniforms
					this.setPerspective(pMatrix);
					this.mainTexture = -1; //Store Our Texture ID
					gl.useProgram(null); //Done setting up shader
				}

				setTexture(texID){ this.mainTexture = texID; return this; }

				//Override
				preRender(){
					//Setup Texture
					this.gl.activeTexture(this.gl.TEXTURE0);
					this.gl.bindTexture(this.gl.TEXTURE_2D, this.mainTexture);
					this.gl.uniform1i(this.uniformLoc.mainTexture,0); //Our predefined uniformLoc.mainTexture is uMainTex, Prev Lessons we made ShaderUtil.getStandardUniformLocations() function in Shaders.js to get its location.

					return this;
				}
			}
		</script>
	</head>
<body>
	<div id="maze" style="height: auto; justify-content: center;">
		<form style="text-align:center" name="forma1">
			<br><label>HEIGHT:</label><br>
			<input type="text" id="height" name="height" autofocus="autofocus" maxlength="2" size="6" />
			<br><label>WIDTH:</label><br>
			<input type="text" id="width" name="width"  maxlength="2" size="6" />
			<br>
		</form>
		<input type="button" alt="submit" onClick="duom();" value="Generate" style="margin-top:10px;" >
		</div>
	<div>
		<canvas id="glcanvas"></canvas>
	</div>
	<img src="UV_Grid_Lrg.jpg" id="imgTex" style="display:none;" crossorigin="anonymous">

	<script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
		in vec3 a_position;	//Standard position data.
		in vec2 a_uv;

		uniform mat4 uPMatrix;
		uniform mat4 uMVMatrix;
		uniform mat4 uCameraMatrix;

		out vec2 uv;
		out vec3 position;
		out highp vec2 texCoord;  //Interpolate UV values to the fragment shader

		void main(void){
			uv = a_uv;
			texCoord = a_uv;
			position = a_position;
			gl_Position = uPMatrix * uCameraMatrix * uMVMatrix * vec4(a_position, 1.0); 
		}
	</script>

	<script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
		precision mediump float;

		in highp vec2 texCoord;		//What pixel to pull from the texture
		in vec2 uv;
		in vec3 position;

		uniform sampler2D uMainTex;	//Holds the texture we loaded to the GPU

		out vec4 finalColor;
		void main(void){
			//Square Border
			/*
			float c = (uv.x <= 0.1 || uv.x >=0.9 || uv.y <= 0.1 || uv.y >= 0.9)? 0.0 : 1.0;
			finalColor = vec4(c,c,c,1.0-c);
			*/

			if(position.y == 0.0){
				float r = 0.5;
				float g = 0.1;
				float b = 0.1;
				finalColor = vec4(r,g,b,1.0);
			} else {
				finalColor = texture(uMainTex, vec2(texCoord.s, texCoord.t));  //Get the color of the pixel at that UV location
			}



			// floorColor fc 
			// float c = vec4(131.0,175.0,82.0,1.0);
			// float c = 0.5;
			// finalColor = vec4(c,c,c,1.0);
			// finalColor = vec4(r,g,b,1.0);

			//Circle
			/*
			vec2 delta = uv - vec2(0.5,0.5); //delta position from center;
			float dist = 0.5 - sqrt(delta.x*delta.x + delta.y*delta.y);

			float border = 0.01;
			float a = 0.0;
			if(dist > border) a = 1.0;
			else if(dist > 0.0) a = dist / border;

			finalColor = vec4(0.0,0.0,0.0,a);
			*/
		}
	</script>


	<!-- <script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
		in vec3 a_position;	//Standard position data.
		layout(location=4) in float a_color;	//Will hold the 4th custom position of the custom position buffer.

		uniform vec3 uColor[4];	//Color Array

		out lowp vec4 color;	//Color to send to fragment shader.
		
		void main(void){
			color = vec4(uColor[ int(a_color) ],1.0); //Using the 4th float as a color index.
			gl_Position = vec4(a_position, 1.0);
		}
	</script>

	<script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
		precision mediump float;

		in vec4 color;
		out vec4 finalColor;
		
		void main(void){ finalColor = color; }
	</script> -->

	
</body>
</html>